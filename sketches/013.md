DECISION:

- \# as single-line comment
- \#= ... =\# as multi-line comment
- \#{ ... } as single-line metadata comment
- \#={ ... }=\# as multi-line metadata comment

units

```
export struct Length
  prop x: Number

impl Add<A>

export struct Meter
  prop x: Number

impl From<Meter> for Length
  fn from(value: Meter): Length =>
    Length(value.x)

export struct Feet
  prop x: Number

impl From<Feet> for Length
  fn from(value: Feet): Length =>
    Length(value.x * 0.3048)
```

3d math

```
import sqrt from @std/math

export struct Vector3<N = Number>
  #{ default = 0 }
  prop x: N

  #{ default = 0 }
  prop y: N

  #{ default = 0 }
  prop z: N

  fn length(self): N =>
    let Self { x, y, z } = self
    sqrt(x * x + y * y + z * z)

export struct Quaternion
  #{ default = 0 }
  prop x: Number

  #{ default = 0 }
  prop y: Number

  #{ default = 0 }
  prop z: Number

  #{ default = 1 }
  prop w: Number
```

3d objects

```
import Length from @std/units
import from @std/3d
  Vector3
  Quaternion

export struct Transform
  prop translation: Vector3<Length>

  prop rotation: Quaternion

  prop scale: Vector3

  fn translate(self, x: Length, y: Length, z: Length): Self =>
    Self
      ...self
      translation = Vector3
        self.translation.x + x
        self.translation.y + y
        self.translation.z + z

export trait Object3d
  prop transform: Transform

  fn translate(self, x: Length, y: Length, z: Length): Self =>
    Self
      ...self
      transform: self.transform.translate(x, y, z)
```

Assembly trait: `assembly.rimu`

```
import Object3d from @std/object-3d
import Stock from @std/stock

export enum Part
  case Stock(impl Stock)
  case Assembly(impl Assembly)

export enum Parts
  case Single(Part)
  case Nested(Self)
  case None

export trait Assembly
  fn parts: Parts

impl Object3d for Assembly
```


Example assembly: `chair.rimu`

```
import Assembly from @std/assembly@1
import GridBeam from @villagekit/gridbeam@1
import SmartFasteners from @villagekit/smart-fasteners@1

export struct Chair
  prop seat_width: Number
    label = 'Seat width'
    min = 5
    max = 10
    step = 5

  prop seat_depth: Number
    label = 'Seat depth'
    min = 5
    max = 15

  prop seat_height: Number
    label = 'Seat height'
    description = 'The height from the ground to the top of the seat'
    min = 5
    max = 15

  prop should_include_back: Bool
    label = 'Include back'

  prop back_height: Number
    label = 'Back height'
    description = 'The height from the seat to the top of the backrest'
    requires = fn(self) => self.should_include_back
    min = 5
    max = 10

  #{ label = "Regular (Without Back) }#
  fn regular(self): Self =>

    Self
      back_height = 10
      seat_depth = 10
      seat_height = 10
      seat_width = 10
      should_include_back = false

  #{ label = "Regular (With Back) }#
  fn regular_with_back(self): Self =>

    Self
      ...Self.regular()
      should_include_back = true

  prop self.plugins = [SmartFasteners()]

impl Assembly
  fn parts(self): Parts =>
    let with self
      seat_width
      seat_depth
      seat_height
      back_height
      should_include_back

    let back_z_beam_end_z = if should_include_back then seat_height + back_height else seat_height
    let seat_panel_start_y = if should_include_back then -1 else 0
    let seat_panel_end_y = if should_include_back then seat_depth - 1 else seat_depth

    parts!
      GridPanel.XY
        x: [0, seat_width]
        y: [seat_panel_start_y, seat_panel_end_y]
        z: seatHeight

      if should_include_back
        GridPanel.XZ
          x: [0, seat_width]
          y: seat_depth - 2
          z: [seat_height + 1, seat_height + 1 + back_height]
          fit: 'top'

      GridBeam.Z
        x: 0
        y: 0
        z: [0, seat_height]

      GridBeam.Z
        x: seat_width - 1
        y: 0
        z: [0, seat_height]

      GridBeam.Z
        x: 0
        y: seat_depth - 1
        z: [0, back_z_beam_end_z]

      GridBeam.Z
        x: seat_width - 1
        y: seat_depth - 1
        z: [0, back_z_beam_end_z]

      GridBeam.X
        x: [0, seat_width]
        y: 1
        z: seat_height - 2

      GridBeam.X
        x: [0, seat_width]
        y: seat_depth - 2
        z: seat_height - 2

      GridBeam.Y
        x: 1
        y: [0, seat_depth]
        z: seat_height - 1

      GridBeam.Y
        x: seat_width - 2
        y: [0, seat_depth]
        z: seat_height - 1
```

Renderable struct `renderable.rimu`

```
export enum Mesh
  case Cuboid
    prop x_length: Length
    prop y_length: Length
    prop z_length: Length

export enum Material
  case Color
    prop color: Color

export struct Instance
  prop mesh: String
  prop material: String
  prop transform: Transform
  prop children: List
    item = Self

export struct Renderable
  prop meshes: Map
    key = String
    value = Mesh
  prop materials: Map
    key = String
    value = Material
  prop instances: List
    item = Instance
```

Stock trait: `stock.rimu`

```
import Object3d from @std/object-3d

export trait Stock: Object3d
  fn render(self): Renderable
```

Example stock part: `gridbeam.rimu`

```
import Stock from @std/stock

export trait GridBeamVariant<GU: Into<Length>>
  type GridUnit = GU

export struct GridBeam<Variant: GridBeamVariant>
  prop variant: Variant

  prop length: Variant.GridUnit
    label = "Length"
    description = "The length of the beam in grid units"

  fn X(
    x: [Variant.GridUnit, Variant.GridUnit]
    y: Variant.GridUnit
    z: Variant.GridUnit
  ): Self =>
    pipe
      Self({ length: abs(x.1 - x.0) })
      _.rotate()
    # ...

impl Stock
  fn render(self): Renderable =>
    # ...
```
