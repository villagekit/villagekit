Play with Rust + Scala + Flix + Julia syntax

https://varkor.github.io/blog/2018/07/30/types-for-units-of-measure.html

```
trait Dimension
  fn new(Number) -> Self
  fn value(&self) -> Number

struct Scalar(Number)

struct Length(Number)

impl Dimension for Length
  fn new(n: Number) -> Self
    Length(n)

  fn value(&self) -> Number
    self.0

struct Time(Number)

impl Dimension for Time
  fn new(n: Number) -> Self
    Time(n)

  fn value(&self) -> Number
    self.0
```

```
use std::ops::{Add, Sub, Mul, Div}

impl<T: Dimension> Add for T
  type Output = T

  fn div(self, rhs: T) -> Self.Output
    Self.new(self.value() + rhs.value())

impl<T: Dimension> Sub for T
  type Output = T

  fn div(self, rhs: T) -> Self.Output
    Self.new(self.value() - rhs.value())

impl<S: Dimension, T: Dimension> Mul<T> for S {
  type Output = DimensionMultiply<S, T>

  fn div(self, rhs: T) -> Self.Output
    DimensionMultiply::new(self.value() * rhs.value())

impl<S: Dimension, T: Dimension> Div<T> for S {
  type Output = DimensionMultiply<S, DimensionInverse<T>>

  fn div(self, rhs: T) -> Self.Output {
    DimensionMultiply::new(self.value() / rhs.value())
```

the problem with this it requires some complex way to know whether two types are equivalent / identical.

requires sophisticated type analysis.

versus https://docs.rs/uom/latest/uom/si/length/index.html

this uses re-usable type tricks to make it happen, only need to have a type system as complex as Rust.

---

i also see https://oss.sonatype.org/service/local/repositories/releases/archive/org/typelevel/squants_2.13/1.6.0/squants_2.13-1.6.0-javadoc.jar/!/squants/space/Length.html

which uses instance methods for dividing one quantity with another. maybe this is the same trick as above.

```
// https://docs.rs/uom/latest/uom/si/trait.Dimension.html
trait Dimension

struct Length
```

---

Or could I do things the original way, but have `From<T>` traits to convert into the appropriate dimensions?

Same for converting between the base units and other units.

```
struct Meter
impl From<Meter> for Length
  fn from(value: Meter) -> Length
    Length(value)

struct Feet
impl From<Feet> for Length
  fn from(value: Feet) -> Length
    Length(value * 0.3048)

impl From<Feet> for Length
```

Then also have a quantity or something.

---


TODO ControlNumber

```
type Part = Stock | Assembly
type Parts = List<Parts | Part>

pub trait Assembly: Object3d
  fn parts() -> Parts

typedef
  prop
```

```
type trait Length
  type num: Num
```

```
typedef RangeNum
  prop min: Num
  prop max: Num
  prop step: Num
```

Built-in traits

```
trait Eq
  type A

  fn eq
    arg x: A
    arg y: A
    res: Bool

  fn neq
    arg x: A
    arg y: A
    res: Bool
  =>
    not Self.eq(x, y)
```

```
enum Comparison
  case LessThan
  case EqualTo
  case GreaterThan


trait Order
  type A

  trait Eq
    type A = A

  fn compare
    arg x: A
    arg y: A
    res: Comparison
```

```
derive impl Eq
  type A = A
```
